<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Configplatform by eganwall</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Configplatform</h1>
        <p>Real-time configuration key-value store using Redis and JS</p>

        <p class="view"><a href="https://github.com/eganwall/ConfigPlatform">View the Project on GitHub <small>eganwall/ConfigPlatform</small></a></p>


        <ul>
          <li><a href="https://github.com/eganwall/ConfigPlatform/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/eganwall/ConfigPlatform/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/eganwall/ConfigPlatform">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="configuration-platform" class="anchor" href="#configuration-platform" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration Platform</h1>

<p>Real-time configuration key-value store using Redis and JS.</p>

<h4>
<a id="overview" class="anchor" href="#overview" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overview</h4>

<p>Lately I've been getting into more Node.js development and have been writing some small, persistent services. I figured that it would be an interesting experiment to create a platform that I could leverage in order to edit the configuration of a service without having to stop, edit, and then restart. These services are running on a headless Raspberry Pi 2, so the convenience of a web-based, remote configuration solution saves me the trouble of SSH'ing into the Pi as well. I got to work and, after a couple of motivated nights, ended up with this codebase. </p>

<p>The configuration setup is comprised of 3 parts: the configuration platform front-end, the configuration monitor, and the consumer applications. Redis is used for persistence and for publisher/subscriber functionality. </p>

<h4>
<a id="basic-flow" class="anchor" href="#basic-flow" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Basic Flow</h4>

<p><img src="http://i.imgur.com/l9GoTt7.png" alt="Config Flow"></p>

<h2>
<a id="the-components" class="anchor" href="#the-components" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Components</h2>

<h4>
<a id="the-configuration-platform" class="anchor" href="#the-configuration-platform" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Configuration Platform</h4>

<p>The configuration platform (configPlatform.js) is the main UI for the setup. It uses Bootstrap and Angular on the front-end, with a Node API on the back-end to enable the communication of the config state with Redis and consuming applications. On page load, the entire config state is retrieved from Redis and presented in a grid. When a config entry is added, edited, or deleted, the JSON object containing the entry's key, value, application name, and GUID is written to Redis, and then published on a master channel so that the configuration monitor service can update the LKGC file.</p>

<h4>
<a id="the-configuration-monitor" class="anchor" href="#the-configuration-monitor" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Configuration Monitor</h4>

<p>configMon.js is a Node.js service responsible for maintaining a local LKGC (last known good configuration) JSON file on the machine that any consuming services are running on. It subscribes to the master channel, and receives every added, updated, or deleted configuration entry. Upon receiving a message on its channel, it will write it to a local LKGC JSON file, which consuming applications will use as the single source of truth for their configuration. After updating the local file, the config monitor will publish another message to the <em>appname</em> channel, where <em>appname</em> is the application name specified in the configuration client. This will allow the service that cares about it to update its in-memory configuration in real time.</p>

<h4>
<a id="the-consuming-application" class="anchor" href="#the-consuming-application" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Consuming Application</h4>

<p>Because the configuration of each application is stored as JSON, any language or framework capable of opening a file and parsing JSON can leverage this functionality to a certain extent. Although Redis functionality is necessary for real-time configuration updates, it's fairly trivial to have an application re-load the LKGC file at 3- or 5-minute intervals in order to capture changes in configuration state. A consuming service will load the LKGC file at startup and store the entries that correspond to its own appname. It will also subscribe to the Redis channel corresponding to its appname, and any changes in config state will be published for the service to handle itself. Since the ConfigMon service will handle updating the local LKGC file, the consuming service only needs to update its internal configuration object that it populated with the LKGC's contents on startup. Basically, as long as the consumer maintains a Redis connection, the configuration can be updated in real-time from the web interface. Neat, huh?</p>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/eganwall">eganwall</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
